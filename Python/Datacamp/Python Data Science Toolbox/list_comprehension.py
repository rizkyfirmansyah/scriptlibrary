""" List Comprehension

nums = [1, 3, 5, 6]
new_nums = [num + 1 for num in nums]

can be applied into nested loops

"""
# Create list comprehension: squares
squares = [i ** 2 for i in range(0, 10)]

# 5 x 5 matrix with values 0 to 4
matrix = [[0, 1, 2, 3, 4],
          [0, 1, 2, 3, 4],
          [0, 1, 2, 3, 4],
          [0, 1, 2, 3, 4],
          [0, 1, 2, 3, 4]]


# Recreate above matrix using nested listed comprehensions

# [[output expression] for iterator variable in iterable]
# Create a 5 x 5 matrix using a list of lists: matrix
matrix = [[col for col in range(5)] for row in range(5)]

# Print the matrix
for row in matrix:
    print(row)

"""
Conditionals in comprehensions

Both can be used: conditionals on the iterable or the output
[ output expression for iterator variable in iterable if predicate expression ].



Dict comprehensions
"""

# Create a list of strings: fellowship
fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']

# Create list comprehension: new_fellowship
new_fellowship = [member for member in fellowship if len(member) >= 7]

# output the new list
# ['samwise', 'aragorn', 'legolas', 'boromir']

# Create list comprehension: new_fellowship
new_fellowship2 = [member if len(member) >= 7 else '' for member in fellowship]

# output the new_fellowship2
# ['', 'samwise', '', 'aragorn', 'legolas', 'boromir', '']

## Dict comprehensions
fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']

# Create dict comprehension: new_fellowship
new_fellowship = { member:len(member) for member in fellowship }

# Print the new list
# {'frodo': 5, 'samwise': 7, 'merry': 5, 'aragorn': 7, 'legolas': 7, 'boromir': 7, 'gimli': 5}

"""
#### GENERATORS ####### LAZY EVALUATION ####

Exactly the same syntax as comprehensions, except wrapping by () instead of []
They don't store in the memory; Great deal when working with extremely large sequences!!

result = (num for num in range(6))
print(list(result))

### GENERATOR FUNCTIONS ###

Generator functions are functions that, like generator expressions, yield a series of values, instead of returning a single value.
A generator function is defined as you do a regular function, but whenever it generates a value, it uses the keyword yield instead of return.

"""

# Create generator object: result
result = (num for num in range(0, 31))

# Print the first 5 values
print(next(result))
print(next(result))
print(next(result))
print(next(result))
print(next(result))

# Print the rest of the values
for value in result:
    print(value)


# Create a list of strings: lannister
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Create a generator object: lengths
lengths = (len(person) for person in lannister)

# Iterate over and print the values in lengths
for value in lengths:
    print(value)

# Create a list of strings
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Define generator function get_lengths
def get_lengths(input_list):
    """Generator function that yields the
    length of the strings in input_list."""

    # Yield the length of a string
    for person in input_list:
        yield len(person)

# Print the values generated by get_lengths()
for value in get_lengths(lannister):
    print(value)


# Extract the created_at column from df: tweet_time
tweet_time = df['created_at']

# Extract the clock time: tweet_clock_time
tweet_clock_time = [entry[11:19] for entry in tweet_time]

# Print the extracted times
print(tweet_clock_time)


"""
In this exercise, you will be using a list comprehension to extract the time from time-stamped Twitter data. You will add a conditional expression to the list comprehension so that you only select the times in which entry[17:19] is equal to '19'
"""
# Extract the created_at column from df: tweet_time

# Extract the clock time: tweet_clock_time
tweet_clock_time = [entry[11:19] for entry in tweet_time if entry[17:19] == '19']
